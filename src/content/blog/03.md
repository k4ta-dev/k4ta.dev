---
title: How TF React works
date: 2025-10-31
excerpt: I finally understood it, gotta document
---

Before actually learning the react, i always took this framework as just abstraction layer over the vanilla JS. Which obviously isn't true, it's a very complex optimization engine and honestly, i have to document why:

## DOM

**DOM** is a live, tree-shaped representation of an HTML document, hence the name *Document Object Model*. 

Apart from rendering, it visually builds a data structure in memory where every element `<div> <p> <img>` becomes a **node** in this tree.

So, something like:

```html
<body>
  <div id="container">
    <p>Hello, world!</p>
  </div>
</body>
```

Becomes an im-memory structure, roughly like:

```json
{
  "nodeName": "HTML",
  "attributes": {},
  "children": [
    {
      "nodeName": "BODY",
      "attributes": {},
      "children": [
        {
          "nodeName": "DIV",
          "attributes": {
            "id": "container"
          },
          "children": [
            {
              "nodeName": "P",
              "attributes": {},
              "children": [
                {
                  "nodeName": "#text",
                  "attributes": {},
                  "children": [
                    "Hello, world!"
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

## The Browser's Role

When you load that HTML, the browser:

1. Parses HTML 
2. Parses CSS
3. Combines them in a render tree
4. Renders pixels on the screen

When one wants to change the DOM via JS, say, `document.body.appendChild(...)`, the browser must:

- Update it's internal DOM tree
- Reflow
- Repaint whats changed.

**Thatâ€™s why direct DOM manipulation can be expensive if done frequently or inefficiently, It is a complex shared stateful system**

## React

This is where the React comes in. It flips the DOM mental model, instead of manually manipulating the DOM, you describe the final desired state of your UI given some data, and React figures out the minimal set of ops to make the real DOM match it. *Describe waht you want, not how to do it*.

I know that makes no sense, so:

1. Building DOM

Basically, react reads all the JSX code, turns them into plain JS objects, like:

```json
{
  type: "div",
  props: { className: "container", children: [...] }
}
```

And builds very efficient, in-memory DOM. This part is pure computation, nothing touches the browser yet. This special DOM is extremely efficent compared to the actual DOM, so doing ops here is not expensive. 

2. Reconciliation, or basically diffing old vs new virtual DOM.

Whenever state or props change, React runs the component again and builds a new virtual DOM tree.

Then it diffs the new tree against the previous one:

- If a node's `type` is the same, so let's say `<div>` remains `<div>` after diffing, React reuses it.
- If it's different (`<div> -> <p>`), React replaces that part.
- If only text or props changed, React updates just those attributes.

So this process simply figures out what actually changed, so React doesn't have to rebuild entire DOM again.

3. Commit Phase

Once React knows what needs to change, it performs the minimal DOM mutations:

- Adding/removing/updating elements
- Updating attributes or event listeners
- Setting text content

This is the only part where React touches the real DOM, and it happens batched and efficiently.

After that, React runs any `useLayoutEffect` hooks then `useEffect` hooks.

## That is why React is more efficient for large scale applications

Because it simply doesn't f*cks with actual, supper inneficient DOM, and only alters it's own robust version in-memory tree and commits changes to the actual thing in batches. 

## What about `useEffect`?

Out of every hooks, this one needs to be understood at first because without this, you wouldn't be able to do impure ops. 

React functional components, the very building blocks of every app are **pure** by design. That means:

- Given the same inputs (props, state), they should always return the same UI.
- They shouldn't perform side effects (like fetching data, touching the DOM or setting timers) during render.

Why? Because React will call those components multiple times while reconciling, i.e shaking the tree. Sometimes even discard one mid-render. **Can you imagine if you had API calls in those components? It would be called so many times, causing unexpected results**.

So we need a way to perform those impure actions (mostly calling the external API) only after 3rd phase of the react lifecycle, when the virtual DOM changes are commited to the actual DOM.

Thus the `useEffect` hook.

```jsx
useEffect(() => {
  const id = setInterval(() => console.log("tick"), 1000);
  return () => clearInterval(id); // cleanup
}, []); // run once
```

Anything in this hook will only run once (given no deps) after the changes are commited to the DOM.

Best example i could think of this is when you want to check users authentication state, the actual call and state setting would go inside the useEffect, you don't want that authentication check to be performed for now reason during the diffing phase.

*There is another hook that actually goes before the `useEffect`, but we don't care. If you get here, just go learn it yourself*






